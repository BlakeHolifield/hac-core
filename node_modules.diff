diff --git a/test/dynamic-plugin-sdk-utils/dist/index.js b/test/dynamic-plugin-sdk-utils/dist/index.js
index bce13de..5313507 100644
--- a/test/dynamic-plugin-sdk-utils/dist/index.js
+++ b/test/dynamic-plugin-sdk-utils/dist/index.js
@@ -79,6 +79,9 @@ const isUtilsConfigSet = () => {
  * This must be done before using any of the Kubernetes utilities.
  */
 const setUtilsConfig = (c) => {
+    if (config !== undefined) {
+        throw new Error('UtilsConfig reference has already been set');
+    }
     config = Object.freeze({ ...c });
 };
 /**
@@ -199,7 +202,7 @@ var WebSocketState;
 class WebSocketFactory {
     constructor(
     /** Unique identifier for the web socket. */
-    id,
+    id, 
     /** Options to configure the web socket with. */
     options) {
         this.id = id;
@@ -1005,7 +1008,7 @@ const getResources = async () => {
     }, {});
     const all = _.flatten(apiResourceData.groups.map((group) => group.versions.map((version) => `/apis/${version.groupVersion}`)))
         .concat(['/api/v1'])
-        .map((p) => commonFetchJSON(`${p}`).catch((err) => err));
+        .map((p) => commonFetchJSON(`api/kubernetes${p}`).catch((err) => err));
     return Promise.all(all).then((data) => {
         const resourceSet = new Set();
         const namespacedSet = new Set();
@@ -1362,11 +1365,7 @@ const SDKReducers = Object.freeze({
  * ```
  */
 const useReduxStore = () => {
-    let storeContext = false;
-    try {
-        storeContext = useStore();
-    } catch (e) {}
-
+    const storeContext = useStore();
     const [storeContextPresent, setStoreContextPresent] = React.useState(false);
     const store = React.useMemo(() => {
         if (storeContext) {
@@ -1403,27 +1402,19 @@ const useReduxStore = () => {
  */
 const AppInitSDK = ({ children, configurations }) => {
     const { store, storeContextPresent } = useReduxStore();
-    const [canRender, setCanRender] = React.useState(false);
     const { appFetch, pluginStore, wsAppSettings, apiDiscovery = initAPIDiscovery } = configurations;
-
     React.useEffect(() => {
         try {
-            setUtilsConfig({ appFetch, wsAppSettings });
-            setCanRender(true)
+            if (isUtilsConfigSet()) {
+                setUtilsConfig({ appFetch, wsAppSettings });
+            }
             apiDiscovery(store);
         }
         catch (e) {
             consoleLogger.warn('Error while initializing AppInitSDK', e);
         }
-    }, [apiDiscovery, store]);
-
-    if (!canRender) {
-        console.debug('>>>>>>>dead');
-        return null;
-    }
-    console.debug('>>>>>>>live');
-
-    return (React.createElement(PluginStoreProvider, { store: pluginStore }, !storeContextPresent ? React.createElement(Provider, { store: store }, children()) : children()));
+    }, [apiDiscovery, appFetch, store, wsAppSettings]);
+    return (React.createElement(PluginStoreProvider, { store: pluginStore }, !storeContextPresent ? React.createElement(Provider, { store: store }, children) : children));
 };
 
 class NoModelError extends CustomError {
diff --git a/test/dynamic-plugin-sdk/dist/index.js b/test/dynamic-plugin-sdk/dist/index.js
index b7bd978..6299642 100644
--- a/test/dynamic-plugin-sdk/dist/index.js
+++ b/test/dynamic-plugin-sdk/dist/index.js
@@ -276,24 +276,19 @@ class PluginLoader {
                 return;
             }
             data.entryCallbackFired = true;
-            console.debug('+++++', entryModule);
-
-            const x = entryModule
-              .init(this.options.getSharedScope())
-            console.debug('======', x);
-
-            // x
+            entryModule
+                .init(this.options.getSharedScope())
                 // eslint-disable-next-line promise/always-return -- entryModule.init() returns Promise<void>
-                // .then(() => {
+                .then(() => {
                 data.status = 'loaded';
                 consoleLogger.info(`Entry script for plugin ${pluginName} loaded successfully`);
                 this.invokeListeners(pluginName, { success: true, manifest: data.manifest, entryModule });
-            // })
-            //     .catch((e) => {
-            //     data.status = 'failed';
-            //     consoleLogger.error(`Failed to initialize shared modules for plugin ${pluginName}`, e);
-            //     this.invokeListeners(pluginName, { success: false });
-            // });
+            })
+                .catch((e) => {
+                data.status = 'failed';
+                consoleLogger.error(`Failed to initialize shared modules for plugin ${pluginName}`, e);
+                this.invokeListeners(pluginName, { success: false });
+            });
         };
     }
     /**
@@ -302,12 +297,12 @@ class PluginLoader {
     registerPluginEntryCallback(getWindow = _.constant(window)) {
         const windowGlobal = getWindow();
         const callbackName = this.options.entryCallbackName;
-        // if (this.entryCallback !== undefined) {
-        //     throw new Error(`Global function ${callbackName} is already registered by this loader`);
-        // }
-        // if (typeof windowGlobal[callbackName] === 'function') {
-        //     throw new Error(`Global function ${callbackName} is already registered by another loader`);
-        // }
+        if (this.entryCallback !== undefined) {
+            throw new Error(`Global function ${callbackName} is already registered by this loader`);
+        }
+        if (typeof windowGlobal[callbackName] === 'function') {
+            throw new Error(`Global function ${callbackName} is already registered by another loader`);
+        }
         this.entryCallback = this.createPluginEntryCallback();
         windowGlobal[callbackName] = this.entryCallback;
     }
@@ -659,7 +654,7 @@ class PluginStore {
  */
 const createMethodDelegate = (
 /** Target object to delegate to. */
-target,
+target, 
 /** Methods on the target object to expose on the delegate object. */
 methodNames) => {
     const delegate = {};
